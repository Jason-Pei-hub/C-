# C语言—字符串函数

## 字符串函数介绍

### strlen

```c
size_t strlen ( const char * str );
```

* 字符串已经 '\0' 作为结束标志，strlen函数返回的是在字符串中 '\0' 前面出现的字符个数（不包 含 '\0' )。
* 参数指向的字符串必须要以 '\0' 结束。 
* 注意函数的返回值为size_t，**是无符号的** 
* 学会strlen函数的模拟实现

```c
#include <stdio.h>
int main()
{
 const char*str1 = "abcdef";
 const char*str2 = "bbb";
 if(strlen(str2)-strlen(str1)>0)
 {
 printf("str2>str1\n");
 } 
 else
 {
 printf("srt1>str2\n");
 }
 return 0;
}
```

大家思考一下，这个程序的运行结果是什么？

因为返回的是无符号整型，那么怎么能出来负数呢？

**一定要会模拟这个函数**

```c
int my_strlen(const char * str)
{
 int count = 0;
 while(*str)//"\0"即为0，假
 {
 count++;
 str++;
 }
 return count;
}
```



### strcpy

 ![image-20240417230214006](https://gitee.com/jason_pei/typora-bed/raw/master/image/202404172302048.png)

```c
char* strcpy(char * destination, const char * source );
```

* 源字符串必须以 '\0' 结束。 
* 会将源字符串中的 '\0' 拷贝到目标空间。 
* 目标空间必须足够大，以确保能存放源字符串。 
* 目标空间必须可变。 
* 学会模拟实现。



### strcat

![image-20240417230559853](https://gitee.com/jason_pei/typora-bed/raw/master/image/202404172305884.png)

字符串追加

* 源字符串必须以 '\0' 结束。 
* 目标空间必须有足够的大，能容纳下源字符串的内容。 
* 目标空间必须可修改。 
* 字符串自己给自己追加，可以吗？

当然是不可以的，字符串内容被修改，无法找到\0，程序会死循环

### strcmp

![image-20240417231046161](https://gitee.com/jason_pei/typora-bed/raw/master/image/202404172310196.png)

```c
int strcmp ( const char * str1, const char * str2 );
```

标准规定： 

* 第一个字符串大于第二个字符串，则返回大于0的数字 
* 第一个字符串等于第二个字符串，则返回0 
* 第一个字符串小于第二个字符串，则返回小于0的数字



## 长度受限制字符串函数

* 相对更加安全
* strncpy
* strncat
* strncmp

> 可以减小我们程序出现问题的可能，大家有兴趣可以下去查一下

这些函数我们最好也尝试自己去实现

### strncpy

[cplusplus.com/reference/cstring/strncpy/](https://cplusplus.com/reference/cstring/strncpy/)

### strncat

[cplusplus.com/reference/cstring/strncat/](https://cplusplus.com/reference/cstring/strncat/)

### strncmp

[cplusplus.com/reference/cstring/strncmp/](https://cplusplus.com/reference/cstring/strncmp/)

### strstr（查找子串）

```c
const char * strstr ( const char * str1, const char * str2 );      char * strstr (char * str1, const char * str2 );
```

![image-20240417232005764](https://gitee.com/jason_pei/typora-bed/raw/master/image/202404172320805.png)

查找str1中是否有str2的字串

找到时返回char*指针，指向字串头指针

找不到是返回空指针

```c
/* strstr example */
#include <stdio.h>
#include <string.h>
int main ()
{
  char str[] ="This is a simple string";
  char * pch;
  pch = strstr (str,"simple");
  strncpy (pch,"sample",6);
  puts (str);
  return 0;
} 
```

需要学会实现

这个函数在数据结构中好像有过讲解，以后会写文章详细讲解

### strtok（字符串切割）

```c
char * strtok ( char * str, const char * sep );
```

![image-20240417232315504](https://gitee.com/jason_pei/typora-bed/raw/master/image/202404172323550.png)

- `str`：要分割的字符串，第一次调用时传入需要分割的字符串，后续调用时传入 NULL。
- `delim`：分隔符，即根据此字符集中的任何字符进行分割。

**返回值**

- 如果成功找到了分割后的片段，则返回指向该片段的指针。
- 如果找不到分隔符或者传入的字符串为空，则返回 NULL。

**注意**

- 在第一次调用 `strtok` 时，需要传入要分割的字符串，并且在后续调用中传入 NULL。
- `strtok` 函数使用静态变量来保存上一次分割的位置，因此不是线程安全的，应当避免在多线程环境下使用。
- 分割后的片段会修改原始字符串，将分隔符替换为 NULL，因此在使用返回的片段时要注意不要修改原始字符串。
- 如果要分割多个字符串，建议使用 `strtok_r` 函数，它是 `strtok` 的线程安全版本。

可以看一下演示

```c
#include <stdio.h>
#include <string.h>

int main() {
    char str[] = "Hello,world,this,is,a,test";
    char *token = strtok(str, ",");

    while (token != NULL) {
        printf("%s\n", token);
        token = strtok(NULL, ",");
    }

    return 0;
}
```

以上示例将会输出：

```c
Hello
world
this
is
a
test
```

这里将字符串按照逗号分割成了多个片段，并依次输出每个片段。

奇奇怪怪的函数



