# C语言函数—递归



> 这方面内容涉及到栈的使用，我们的递归函数如果被执行那么系统将会自动的去创建一个栈，相关内容有机会单独写文章讲解

---

## 什么是递归？

> 程序调用自身的编程技巧称为递归（ recursion）。 
>
> 递归做为一种算法在程序设计语言中广泛应用。
>
>  一个过程或函数在其定义或说明中有直接或间接 调用自身的 一种方法，它通常把一个大型复杂的问题层层转化为一个与原问题相似的规模较小的问题来求解， 递归策略 只需少量的程序就可描述出解题过程所需要的多次重复计算，大大地减少了程序的代码量。 
>
> **递归的主要思考方式在于：把大事化小**

写一个简单的递归函数看看什么效果

```c
int main()
{
	printf("hehe");
	main();
	return 0;
}
```

运行结果

![image-20240314211920562](https://gitee.com/jason_pei/typora-bed/raw/master/image/202403142119612.png)

这是个错误的示范，大家别尝试，看一下结果就好

>  overflow 栈溢出了

### 递归的两个必要条件

* 存在限制条件，当满足这个限制条件的时候，递归便不再继续。
* 每次递归调用之后越来越接近这个限制条件。

---

当然，这样子看可能会不是很清楚，我们来通过简单的例子来学习什么是递归函数

####  练习：

> 接受一个整型值（无符号），
>
> 按照顺序打印它的每一位。 
>
> 例如： 输入：1234，输出 1 2 3 4

**解题思路**

这道题很简单，相信大家都会做，我们每次模10，就可以得到末位

**1234 % 10 = 4**

我们每次除10就可以去掉最后一位，再求模就可以得到末位

1234 / 10 = 123

**123 % 10 = 3**

123 / 10 = 12

**12 % 10 = 2**

12 / 10 = 1

**1 % 10 = 1**

那我们打印顺序就变成了 4 3 2 1，怎么办呢，可以存在数组倒着打印，有没有更简单的办法

#### 递归怎么去做呢？

```c
print(1234)
print(123)   4//把最后一位取出来打印
print(12)  3 4
print(1) 2 3 4//需要处理打印的数字越来越小，直到最后的1，那就很简单
//我们现在就把问题转换成了与原问题相似，但是比原问题简单的问题
```



```c
#include <stdio.h>
void print(int n)//void 我们不需要返回值，在函数内直接打印就行
{
	if (n > 9)//意味着不是一个个位数，至少是两位
	{
		print(n / 10);//函数自己调用自己
	}
	printf("%d ", n % 10);
}
int main()
{
	int num = 1234;
	print(num);
    //调用函数，打印每一位
	return 0;
}
```

可能不是很好理解，什么意思呢？

我尽量画一个图来展示一下过程

![1ff9df8b7877de328485b31a38dca35](https://gitee.com/jason_pei/typora-bed/raw/master/image/202403142257954.jpg)

这里要明白的是，if函数内的循环执行完才会执行下一条语句打印语句，可实际上每一次执行if函数都直接又重新开始，直到不再进入if函数，才开始一层一层往上的去执行完打印语句，大家可以参照图理解

> 黄色框即为栈

栈区空间并不是无限的，递归函数实际上很容易就会遇到递归层次过深二引起的栈区空间用尽，也就是栈溢出（Stack overflow）



### 注意

**所以当我们在写递归代码时：**

1. 不能死递归，都要有跳出条件，每次递归都要逼近跳出条件
2. 递归层次不能太深

---



**分享一下程序员的知乎**

https://stackoverflow.com/

> 1. 英文提问，英文回答
> 2. 可以了解一下这个网站，以后跟面试官有的聊