# 深度剖析数据在内存中的存储

## 数据类型介绍

前面我们已经学习了基本的内置类型：

```c
char        //字符数据类型
short       //短整型
int         //整形
long        //长整型
long long   //更长的整形
float       //单精度浮点数
double      //双精度浮点数
//C语言有没有字符串类型？
```

以及他们所占存储空间的大小。 

**类型的意义：**

1. 使用这个类型开辟内存空间的大小（大小决定了使用范围）。 
2.  如何看待内存空间的视角。

## 类型的基本归类

### 整型家族

```c
char
//本质是ASCII码值，是整型，所以划分到整型家族
 char
 unsigned char
 signed char
 //char到到底是signed char还是unsigned char取决于编译器
short
 unsigned short [int]
 signed short [int]
int
 unsigned int
 signed int
long
 unsigned long [int]
 signed long [int]
```

下面的类型只要是没标unsigned都是有符号的

生活中有很多数据都是没有负数的

>  身高、体重、长度

```c
int a = 10;
a是一个整型，有符号的整型，一个整形是四个字节=32bit
00000000 00000000 00000000 00001010
最高位即为符号位，符号位是0表示正数
```

### 浮点型家族

```c
float
//精度低，存储范围小
double
```

### 构造类型

```c
> 数组类型    int[5]
> 结构体类型 struct
> 枚举类型 enum
> 联合类型 union
```

### 指针类型

```c
int *pi;
char *pc;
float* pf;
void* pv;
```

### 空类型

> void 表示空类型（无类型） 
>
> 通常应用于函数的返回类型、函数的参数、指针类型。

---

## 整型在内存中的存储

我们之前讲过一个变量的创建是要在内存中开辟空间的。空间的大小是根据不同的类型而决定的。

```c
int a = 20;
int b = -10;
```

我们知道为 a 分配四个字节的空间。

 那如何存储？

 下来了解下面的概念：

## 原码、反码、补码

计算机中的整数有三种表示方法，即原码、反码和补码。三种表示方法均有符号位和数值位两部分，符号位都是用 0 表示“正”，用 1 表示“负”，而数值位负整数的三种表示方法各不相同。

- **原码**：直接将二进制按照正负数的形式翻译成二进制就可以。
- **反码**：将原码的符号位不变，其他位依次按位取反就可以得到。
- **补码**：反码+1 就得到补码。正数的原、反、补码都相同。

在计算机系统中，数值一律用补码来表示和存储。原因在于，使用补码可以将符号位和数值域统一处理；同时，加法和减法也可以统一处理（CPU 只有加法器）。此外，补码与原码相互转换，其运算过程是相同的，不需要额外的硬件电路。

正数的原、反、补码都相同。 

对于整形来说：数据存放内存中其实存放的是补码。 

为什么呢？

在计算机中，正数的原码、反码和补码都相同，因为它们的符号位都是 0。而在计算机系统中，数据一般以补码的形式存储在内存中。这是因为补码表示方式有以下优势：
- 统一处理符号位和数值域，简化处理逻辑。
- 加法和减法可以统一处理，无需额外的硬件电路。
- 只需要加法器，减法可以转换为加法操作。

内存中存储顺序可能与预期不同，这可能受计算机的字节序影响，即小端序和大端序的差异。因此，观察到变量存储的补码顺序不对劲可能是因为字节序不同导致的。

## 大小端存储

什么大端小端：

> 大端（存储）模式，是指数据的低位保存在内存的高地址中，而数据的高位，保存在内存的低地址 中；
>
>  小端（存储）模式，是指数据的低位保存在内存的低地址中，而数据的高位,，保存在内存的高地 址中。

为什么有大端和小端：

> 为什么会有大小端模式之分呢？这是因为在计算机系统中，我们是以字节为单位的，每个地址单元 都对应着一个字节，一个字节为8 bit。但是在C语言中除了8 bit的char之外，还有16 bit的short型，32 bit的long型（要看具体的编 译器），另外，对于位数大于8位 的处理器，例如16位或者32位的处理器，由于寄存器宽度大于一个字节，那么必然存在着一个如 何将多个字节安排的问题。因此就 导致了大端存储模式和小端存储模式。 例如：一个 16bit 的 short 型 x ，在内存中的地址为 0x0010 ， x 的值为 0x1122 ，那么 0x11 为 高字节， 0x22 为低字节。对于大端 模式，就将 0x11 放在低地址中，即 0x0010 中， 0x22 放在高地址中，即 0x0011 中。小端模式， 刚好相反。我们常用的 X86 结构是 小端模式，而 KEIL C51 则为大端模式。很多的ARM，DSP都为小端模式。有些ARM处理器还可以 由硬件来选择是大端模式还是小端 模式。
