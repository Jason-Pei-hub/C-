# 深度剖析数据在内存中的存储

## 数据类型介绍

前面我们已经学习了基本的内置类型：

```c
char        //字符数据类型
short       //短整型
int         //整形
long        //长整型
long long   //更长的整形
float       //单精度浮点数
double      //双精度浮点数
//C语言有没有字符串类型？
```

以及他们所占存储空间的大小。 

**类型的意义：**

1. 使用这个类型开辟内存空间的大小（大小决定了使用范围）。 
2.  如何看待内存空间的视角。

## 类型的基本归类

### 整型家族

```c
char
 unsigned char
 signed char
short
 unsigned short [int]
 signed short [int]
int
 unsigned int
 signed int
long
 unsigned long [int]
 signed long [int]
```

### 浮点型家族

```c
float
double
```

### 构造类型

```c
> 数组类型
> 结构体类型 struct
> 枚举类型 enum
> 联合类型 union
```

### 指针类型

```c
int *pi;
char *pc;
float* pf;
void* pv;
```

### 空类型

> void 表示空类型（无类型） 
>
> 通常应用于函数的返回类型、函数的参数、指针类型。

---

## 整型在内存中的存储

我们之前讲过一个变量的创建是要在内存中开辟空间的。空间的大小是根据不同的类型而决定的。

```c
int a = 20;
int b = -10;
```

我们知道为 a 分配四个字节的空间。

 那如何存储？

 下来了解下面的概念：

## 原码、反码、补码

计算机中的整数有三种表示方法，即原码、反码和补码。三种表示方法均有符号位和数值位两部分，符号位都是用 0 表示“正”，用 1 表示“负”，而数值位负整数的三种表示方法各不相同。

- **原码**：直接将二进制按照正负数的形式翻译成二进制就可以。
- **反码**：将原码的符号位不变，其他位依次按位取反就可以得到。
- **补码**：反码+1 就得到补码。正数的原、反、补码都相同。

在计算机系统中，数值一律用补码来表示和存储。原因在于，使用补码可以将符号位和数值域统一处理；同时，加法和减法也可以统一处理（CPU 只有加法器）。此外，补码与原码相互转换，其运算过程是相同的，不需要额外的硬件电路。

正数的原、反、补码都相同。 

对于整形来说：数据存放内存中其实存放的是补码。 

为什么呢？

在计算机中，正数的原码、反码和补码都相同，因为它们的符号位都是 0。而在计算机系统中，数据一般以补码的形式存储在内存中。这是因为补码表示方式有以下优势：
- 统一处理符号位和数值域，简化处理逻辑。
- 加法和减法可以统一处理，无需额外的硬件电路。
- 只需要加法器，减法可以转换为加法操作。

内存中存储顺序可能与预期不同，这可能受计算机的字节序影响，即小端序和大端序的差异。因此，观察到变量存储的补码顺序不对劲可能是因为字节序不同导致的。

