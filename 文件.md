# 文件

---

## 什么是文件

磁盘上的文件是文件。 但是在程序设计中，我们一般谈的文件有两种：程序文件、数据文件（从文件功能的角度来分类的）。

**程序文件**

> 包括源程序文件（后缀为.c）,目标文件（windows环境后缀为.obj）,可执行程序（windows环境 后缀为.exe）。

**数据文件**

> 文件的内容不一定是程序，而是程序运行时读写的数据，比如程序运行需要从中读取数据的文件， 或者输出内容的文件。



在以前所处理数据的输入输出都是以终端为对象的，即从终端的键盘输入数据，运行结果显示到显示器上。

其实有时候我们会把信息输出到磁盘上，当需要的时候再从磁盘上把数据读取到内存中使用，这里处理 的就是磁盘上文件。

---

## 文件名

一个文件要有一个唯一的文件标识，以便用户识别和引用。 

**文件名包含3部分**：`文件路径`+`文件名主`干+`文件后缀` 

例如： c:\code\test.txt 为了方便起见，文件标识常被称为文件名。

---

## 文件的打开和关闭

### 文件指针

缓冲文件系统中，关键的概念是**“文件类型指针”**，简称**“文件指针”**。 

每个被使用的文件都在内存中开辟了一个相应的文件信息区，用来存放文件的相关信息（如文件的名字，文件状态及文件当前的位置等）。

这些信息是保存在一个结构体变量中的。该结构体类型是有系统 声明的，取名**FILE**.



我们可以从VS提供的编译环境看到stdio.h中有以下文件类型声明：

```c
struct _iobuf {
        char *_ptr;
        int   _cnt;
        char *_base;
        int   _flag;
        int   _file;
        int   _charbuf;
        int   _bufsiz;
        char *_tmpfname;
       };
typedef struct _iobuf FILE;
```

本质上来说，FILE是一个重命名产生的类型

本质上是结构体

![image-20240428170433490](https://gitee.com/jason_pei/typora-bed/raw/master/image/202404281704590.png)

每当打开一个文件的时候，系统会根据文件的情况自动创建一个FILE结构的变量，并填充其中的信息， 使用者不必关心细节。 

一般都是通过一个FILE的指针来维护这个FILE结构的变量，这样使用起来更加方便。 

下面我们可以创建一个FILE*的指针变量:

```c
FILE* pf;//文件指针变量
```

定义pf是一个指向FILE类型数据的指针变量。可以使pf指向某个文件的文件信息区（是一个结构体变 量）。

通过该文件信息区中的信息就能够访问该文件。

也就是说，**通过文件指针变量能够找到与它关联的文件**

![image-20240428170550275](https://gitee.com/jason_pei/typora-bed/raw/master/image/202404281705304.png)

# 文件的打开和关闭

文件在读写之前应该先**打开文件**，在使用结束之后应该**关闭文件**。

在编写程序的时候，在打开文件的同时，都会返回一个FILE*的指针变量指向该文件，也相当于建立了指 针和文件的关系。

ANSIC 规定使用**fopen函数**来打开文件，**fclose**来关闭文件。

## fopen

```c
FILE * fopen ( const char * filename, const char * mode );
```

文件名和文件打开方式

文件打开方式有哪些呢？

![image-20240428171145043](https://gitee.com/jason_pei/typora-bed/raw/master/image/202404281711076.png)

| 文件使用方式 | 含义                                                     | 如果指定文件不存在 |
| ------------ | -------------------------------------------------------- | ------------------ |
| "r"          | 只读，为了输入数据，打开一个已经存在的文本文件           | 出错               |
| "w"          | 只写，为了输出数据，打开一个文本文件，建立一个新的文件   | 建立一个新的文件   |
| "a"          | 追加，向文本文件尾添加数据，建立一个新的文件             | 建立一个新的文件   |
| "rb"         | 只读，为了输入数据，打开一个二进制文件                   | 出错               |
| "wb"         | 只写，为了输出数据，打开一个二进制文件，建立一个新的文件 | 建立一个新的文件   |
| "ab"         | 追加，向一个二进制文件尾添加数据                         | 出错               |
| "r+"         | 读写，为了读和写，打开一个文本文件                       | 出错               |
| "w+"         | 读写，为了读和写，建立一个新的文件                       | 建立一个新的文件   |
| "a+"         | 读写，打开一个文件，在文件尾进行读写                     | 建立一个新的文件   |
| "rb+"        | 读写，为了读和写打开一个二进制文件                       | 出错               |
| "wb+"        | 读写，为了读和写，新建一个新的二进制文件                 | 建立一个新的文件   |
| "ab+"        | 读写，打开一个二进制文件，在文件尾进行读和写             | 建立一个新的文件   |

如何判断打开失败呢？

```c
int main()
{
	FILE* pf;
	//打开文件
	pf = fopen("text.txt", "r");
	//文件操作
	if (pf == NULL)
	{
		printf("%s\n", strerror(errno));
		return 1;
	}
	//读取文件
	//关闭文件
	fclose(pf);
	pf = NULL;
	return 0;
}
```

我们新建一个文件看看能否打开

![image-20240428172639284](https://gitee.com/jason_pei/typora-bed/raw/master/image/202404281726313.png)

不报错说明正常打开

# 文件的读写

## 文件的顺序读写

| 功能       | 函数名  | 适用于     |
| ---------- | ------- | ---------- |
| 字符输入   | fgetc   | 所有输入流 |
| 字符输出   | fputc   | 所有输出流 |
| 文本行输入 | fgets   | 所有输入流 |
| 文本行输出 | fputs   | 所有输出流 |
| 格式化输入 | fscanf  | 所有输入流 |
| 格式化输出 | fprintf | 所有输出流 |
| 二进制输入 | fread   | 文件       |
| 二进制输出 | fwrite  | 文件       |

### fputc

```c
int fputc ( int character, FILE * stream );
```

很好理解，传参为，写入字符ASCII码值以及文件指针

我们运行以下看看效果

```c
int main()
{
	FILE* pf;
	//打开文件
	pf = fopen("text.txt", "w");
	//文件操作
	if (pf == NULL)
	{
		printf("%s\n", strerror(errno));
		return 1;
	}
	//写文件
	char i = 0;
	for(i = 'a';i <= 'z';i++)
	fputc(i, pf);
	//关闭文件
	fclose(pf);
	pf = NULL;
	return 0;
}
```

![image-20240428174529651](https://gitee.com/jason_pei/typora-bed/raw/master/image/202404281745700.png)

### fgetc

```c
int fgetc ( FILE * stream );
```

传入值为文件指针

返回类型为字符的ascii码值

我们来试一下

```c
int main()
{
	FILE* pf;
	//打开文件
	pf = fopen("text.txt", "r");
	//文件操作
	if (pf == NULL)
	{
		printf("%s\n", strerror(errno));
		return 1;
	}
	//读文件
	char i = 0;
	while ((i = fgetc(pf)) != EOF)
	{
		printf("%c", i);
	}
	fgetc(pf);
	//关闭文件
	fclose(pf);
	pf = NULL;
	return 0;
}
```

![image-20240428175030633](https://gitee.com/jason_pei/typora-bed/raw/master/image/202404281750676.png)

### fputs

```c
int fputs ( const char * str, FILE * stream );
```

写一行数据

```c
int main()
{
	FILE* pf;
	//打开文件
	pf = fopen("text.txt", "w");
	//文件操作
	if (pf == NULL)
	{
		printf("%s\n", strerror(errno));
		return 1;
	}
	//写一行数据
	fputs("hello world!", pf);
	//关闭文件
	fclose(pf);
	pf = NULL;
	return 0;
}

```

![image-20240428175348683](https://gitee.com/jason_pei/typora-bed/raw/master/image/202404281753725.png)

### fgets

```c
char * fgets ( char * str, int num, FILE * stream );
```

![image-20240428180254036](https://gitee.com/jason_pei/typora-bed/raw/master/image/202404281802072.png)

其实也很好理解，传入的分别为字符串存放的地址，要读取的最大字数，文件指针

读取一行数据，我们来试一下

```c
int main()
{
	FILE* pf;
	//打开文件
	pf = fopen("text.txt", "r");
	//文件操作
	if (pf == NULL)
	{
		printf("%s\n", strerror(errno));
		return 1;
	}
	//读一行数据
	char arr[20];
	fgets(arr, 20, pf);
	printf(arr);
	//关闭文件
	fclose(pf);
	pf = NULL;
	return 0;
}
```

![image-20240428175911870](https://gitee.com/jason_pei/typora-bed/raw/master/image/202404281759916.png)